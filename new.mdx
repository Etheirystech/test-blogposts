---
title: 'This is my New Article'
date: '2023-04-18'
tags: ['next.js','nextjs','new']
---

We recommend using **Static Generation** (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.

```ts
const sum = (num1: number, num2: number): number => {
    return num1 + num2
}

console.log(sum(4,8)) //12
```

You can use Static Generation for many types of pages, including:

- Marketing pages
- Blog posts
- E-commerce product listings
- Help and documentation

You should ask yourself: "Can I pre-render this page **ahead** of a user's request?" If the answer is yes, then you should choose Static Generation.

On the other hand, Static Generation is **not** a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.

In that case, you can use **Server-Side Rendering**. It will be slower, but the pre-rendered page will always be up-to-date. Or you can skip pre-rendering and use client-side JavaScript to populate data.
=======
title: "Chapter 9: My New Post"
date: '2023-10-02'
tags: ["next.js", 'nextjs']
---

# Chapter 4: SSR, SSG, ISR

When we run `build` on our project, Next.js will create different type of pages based on our components,
they can be SSR ( labeled as "Server" ), SSG, ISR ( which will be labeled as "SSG") or SG ( Static Generation labeled as "Static" )

## SSR (Server Side Rendering)
This means that the page will be generated on the server every time a user loads the page and it will then be served to the user.
This method is often used for pages with dynamic data ( data that needs to be fetched on each request )

## SSG (Static Site Generation)
This means that the page will be generated at build time and will be served automatically when user loads the page.

## ISR (Incremental Static Regeneration)
This means that the page will be generated at build time but also regenerated on the server when user loads the page and a specified amount of time has passed since the last regeneration.
This method is great for pages that have data that changes over time, but not necessarily on every request.

## SG (Static Generation)
This means that the HTML was generated for the component during the build time and won't be regenerated again on the server, and in case of client components they will have their HTML prerendered so that they are still good with SEO, and they will still be interactive once the client-side JavaScript is loaded.

## Fetching and cache
By default when we fetch data with the **fetch**() function, the **cache **option of the options object is set to "force-cache", this means that data will be cached and stored indefinitely unless we specified that the data should be revalidated with the **options**.**next**.**revalidate **option.   
We can set the value of **cache **to "no-store" to prevent caching and this will mean that the data will be fetched for every time the **fetch**() is called.

## Fetching and revalidation
If we want to revalidate the data that we cached, we can add the **next **option to the options object which has an object with **revalidate **property as the value.
We can specify time in second as the value to the **revalidate **property which will indicate how much time should pass until the data will become stale.
`**next**:{**revalidate**:**3600**}`

## Converting SSR page to ISR or SSG page
To convert SSR page to ISR or SSG page we need to use the **generateStaticParams **function.   
The **generateStaticParams **function is a custom function meaning we don't **import **it and then call it, but rather create a function that is called **generateStaticParams**.

To use the function we need to **export **the function and the returned value of the function should be an array with objects, and each object should have a property which has the exact same name as the dynamic route, and the value of that property should be the possible route path name.
```
export async function generateStaticParams() {
  const usersData: Promise<User[]> = getAllUsers()
  const users = await usersData;
  return users.map(user => (
      {userId: user.id.toString()}
  ))

}

```

## Handling dynamic route paths that don't exist
To handle cases in which there is a possibility that a user access's a page that doesn't exist we can use the notFound() function.   
To use this function we can simply call it conditionally in case there is no data for that page.   
This function will then render a default Next.js not found page, and if we want to create a custom page we can simply add `not-found.tsx` page.   
   
>>>>>>> 369fce38ffa0f76cdefd01ab04f59397fd53d7f8
